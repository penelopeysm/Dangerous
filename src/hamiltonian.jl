module Hamiltonian

using Unitful: @u_str, Frequency


"""
    σ_X, σ_Y, σ_Z

Single-spin Pauli matrices.
"""
σ_X = [0 1; 1 0] ./ 2
σ_Y = [0 -im; im 0] ./ 2
σ_Z = [1 0; 0 -1] ./ 2

"""
    h_pulse(ω1, φ)

Generate a Hamiltonian for a pulse with a given angular frequency (ω1 = B1/γ)
and pulse phase.

The angular frequency should be specified in rad/s. The pulse phase can be
either specified as an angle in radians, or as one of the following symbols:
`:x`, `:y`, `:_x`, or `:_y`, which correspond respectively to 0, π/2, π, and
3π/2.
"""

using ..SpinSystem: System
using ..Nuclei: γ
using LinearAlgebra: I, kron


"""
    op1(i, n, single_spin_op)

Generate a single-spin operator acting on spin `i` in a system of `n` spins.

e.g. ``I_{1z}`` in a 4-spin system is generated by ``op1(1, 4, σ_Z)``.
"""
function op1(i, n, single_spin_op)
    if n < 1
        throw(ArgumentError("Invalid number of spins $n"))
    end
    if i < 1 || i > n
        throw(ArgumentError("Invalid index $i for $n spins"))
    end
    if i == 1 && n == 1
        return single_spin_op
    else
        kron_list = Matrix{ComplexF64}[I(2) for _ in 1:n]
        kron_list[i] = single_spin_op
        return kron(kron_list...)
    end
end

"""
    op2(i, j, n, single_spin_op1, single_spin_op2)

Generate a two-spin operator between spins `i` and `j` in a system of `n` spins.

e.g. ``I_{1z}I_{2x}`` in a 4-spin system is generated by ``op2(1, 2, 4, σ_Z, σ_X)``.
"""
function op2(i, j, n, single_spin_op1, single_spin_op2)
    if n < 2
        throw(ArgumentError("Invalid number of spins $n"))
    end
    if i < 1 || i > n || j < 1 || j > n
        throw(ArgumentError("Invalid indices $i, $j for $n spins"))
    end
    if i == j
        throw(ArgumentError("Indices $i and $j must be different"))
    end
    kron_list = Matrix{ComplexF64}[I(2) for _ in 1:n]
    kron_list[i] = single_spin_op1
    kron_list[j] = single_spin_op2
    return kron(kron_list...)
end

function X(i, n)
    return op1(i, n, σ_X)
end

function Y(i, n)
    return op1(i, n, σ_Y)
end

function Z(i, n)
    return op1(i, n, σ_Z)
end

function XX(i, j, n)
    return op2(i, j, n, σ_X, σ_X)
end

function YY(i, j, n)
    return op2(i, j, n, σ_Y, σ_Y)
end

function ZZ(i, j, n)
    return op2(i, j, n, σ_Z, σ_Z)
end

function ρ_eq(sys)
    # TODO: Implement this properly
    n = length(sys.nuclei)
    return sum([Z(i, n) for i in 1:n])
end

function detection_operators(sys, nuc)
    n = length(sys.nuclei)
    indices = findall(==(nuc), sys.nuclei)
    return sum([X(i, n) for i in indices]), sum([Y(i, n) for i in indices])
end

function h_offset(sys)
    n = length(sys.nuclei)
    return sum([2π * sys.magnetic_field * γ(sys.nuclei[i]) * (sys.chemical_shifts[i] / 1e6) * Z(i, n) for i in 1:n])
end

function h_coupling(sys)
    n = length(sys.nuclei)
    if n < 2
        return zeros(Float64, 2, 2) * u"Hz"
    end
    return (sum([2π * sys.couplings[i, j] * XX(i, j, n) for i in 1:n for j in 1:n if i != j])
            + sum([2π * sys.couplings[i, j] * YY(i, j, n) for i in 1:n for j in 1:n if i != j])
            + sum([2π * sys.couplings[i, j] * ZZ(i, j, n) for i in 1:n for j in 1:n if i != j]))
end

function h_free(sys)
    return h_offset(sys) + h_coupling(sys)
end

function h_pulse(sys, nuc, ω1::Frequency, φ)
    n = length(sys.nuclei)
    # Assume that pulses only apply to one nucleus
    indices = findall(==(nuc), sys.nuclei)
    # Convert pulse phase to radians if needed
    if φ === :x
        φ = 0
    elseif φ === :y
        φ = π / 2
    elseif φ === :_x
        φ = π
    elseif φ === :_y
        φ = 3π / 2
    end
    single_spin_op = ω1 * (cos(φ) * σ_X + sin(φ) * σ_Y)
    return sum([op1(i, n, single_spin_op) for i in indices])
end

end  # module Hamiltonian

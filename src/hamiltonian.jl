"""
    σ_x

Single-spin Pauli matrix.

```math
\\sigma_x = \\frac{1}{2}\\begin{pmatrix}0 & 1 \\\\ 1 & 0\\end{pmatrix}
```
"""
const σ_x = [0 1; 1 0] ./ 2

"""
    σ_y

Single-spin Pauli matrix.

```math
\\sigma_y = \\frac{1}{2}\\begin{pmatrix}0 & -\\mathrm{i} \\\\ \\mathrm{i} & 0\\end{pmatrix}
```
"""
const σ_y = [0 -im; im 0] ./ 2

"""
    σ_z

Single-spin Pauli matrix.

```math
\\sigma_z = \\frac{1}{2}\\begin{pmatrix}1 & 0 \\\\ 0 & -1\\end{pmatrix}
```
"""
const σ_z = [1 0; 0 -1] ./ 2


"""
    op1(i, n, single_spin_op)

Generate a single-spin operator acting on spin `i` in a system of `n` spins.

e.g. ``I_{1z}`` in a 4-spin system is generated by `op1(1, 4, σ_z)`.
"""
function op1(i, n, single_spin_op)
    if n < 1
        throw(ArgumentError("Invalid number of spins $n"))
    end
    if i < 1 || i > n
        throw(ArgumentError("Invalid index $i for $n spins"))
    end
    if i == 1 && n == 1
        return single_spin_op
    else
        kron_list = Matrix{ComplexF64}[I(2) for _ in 1:n]
        kron_list[i] = single_spin_op
        return kron(kron_list...)
    end
end

"""
    op2(i, j, n, single_spin_op1, single_spin_op2)

Generate a two-spin operator between spins `i` and `j` in a system of `n` spins.

e.g. ``I_{1z}I_{2x}`` in a 4-spin system is generated by `op2(1, 2, 4, σ_z, σ_x)`.
"""
function op2(i, j, n, single_spin_op1, single_spin_op2)
    if n < 2
        throw(ArgumentError("Invalid number of spins $n"))
    end
    if i < 1 || i > n || j < 1 || j > n
        throw(ArgumentError("Invalid indices $i, $j for $n spins"))
    end
    if i == j
        throw(ArgumentError("Indices $i and $j must be different"))
    end
    kron_list = Matrix{ComplexF64}[I(2) for _ in 1:n]
    kron_list[i] = single_spin_op1
    kron_list[j] = single_spin_op2
    return kron(kron_list...)
end

function X(i, n)
    return op1(i, n, σ_x)
end

function Y(i, n)
    return op1(i, n, σ_y)
end

function Z(i, n)
    return op1(i, n, σ_z)
end

function XX(i, j, n)
    return op2(i, j, n, σ_x, σ_x)
end

function YY(i, j, n)
    return op2(i, j, n, σ_y, σ_y)
end

function ZZ(i, j, n)
    return op2(i, j, n, σ_z, σ_z)
end

"""
    ρ_eq(sys)

Generate the thermal density matrix for a spin system. Formally, this is given by

```math
\\rho_{\\text{eq}} = \\frac{\\exp{(-\\beta H)}}{\\text{Tr}[(\\exp{(-\\beta H)]}}
```

where ``\\beta = 1/k_\\mathrm{B}T``, but here we use the approximation of

```math
\\rho_{\\text{eq}} \\propto \\sum_i \\gamma_i I_{iz}.
```

This is justified by the fact that ``H`` is very small (so ``\\exp(-\\beta H)
\\approx 1 - \\beta H``) and that the coupling term is small compared to the
offset term.
"""
function ρ_eq(sys)
    n = length(sys.nuclei)
    # Dimensions can be just removed, since the only effect is to scale
    # the density matrix by a constant factor
    ρ = sum([ustrip(u"MHz/T", γ(sys.nuclei[i])) * Z(i, n) for i in 1:n])
    # Normalise, which seems to give a bit more numerical stability
    return ρ / norm(ρ)
end

"""
    detection_operators(sys, nuc)

Generate the relevant operators for detecting a given nucleus:

```math
X = \\sum_i I_{ix}, \\quad Y = \\sum_i I_{iy}
```

where the sum is over all spins of the given nucleus.
"""
function detection_operators(sys, nuc)
    n = length(sys.nuclei)
    indices = findall(==(nuc), sys.nuclei)
    return sum([X(i, n) for i in indices]), sum([Y(i, n) for i in indices])
end

"""
    h_offset(sys)

Generate the offset Hamiltonian for a spin system, given by:

```math
H_{\\text{offset}} = \\sum_i \\Omega_{0,i} I_{iz}
```

where ``\\Omega_{0,i} = -\\gamma_i B_0 - \\omega_{\\text{ref},i}`` is the offset angular frequency of spin `i`.
"""
function h_offset(sys)
    n = length(sys.nuclei)
    offsets = sys.magnetic_field .* γ.(sys.nuclei) .* (sys.chemical_shifts[i] - sys.transmitter_offset[sys.nuclei[i]] for i in 1:n) / 1e6
    return sum([2π * offsets[i] * Z(i, n) for i in 1:n])
end

"""
    h_coupling(sys)

Generate the spin–spin coupling Hamiltonian for a spin system, given by:

```math
H_{\\text{coupling}} = \\sum_{i \\neq j} 2\\pi J_{ij} (I_{ix}I_{jx} + I_{iy}I_{jy} + I_{iz}I_{jz})
```

where ``J_{ij}`` is the coupling constant between spins `i` and `j` (in Hz).
"""
function h_coupling(sys)
    n = length(sys.nuclei)
    if n < 2
        return zeros(Float64, 2, 2) * u"Hz"
    end
    return (sum([2π * sys.couplings[i, j] * XX(i, j, n) for i in 1:n for j in 1:n if i != j])
            + sum([2π * sys.couplings[i, j] * YY(i, j, n) for i in 1:n for j in 1:n if i != j])
            + sum([2π * sys.couplings[i, j] * ZZ(i, j, n) for i in 1:n for j in 1:n if i != j]))
end

"""
    h_free(sys)

Generate the free Hamiltonian for a spin system.

```math
H_{\\text{free}} = H_{\\text{offset}} + H_{\\text{coupling}}
```
"""
function h_free(sys)
    return h_offset(sys) + h_coupling(sys)
end

"""
    h_pulse(sys, nuc, ω1, φ)

Generate a Hamiltonian for a pulse on nucleus `nuc`, with angular frequency
(`ω1 = B1/γ`) and pulse phase `φ`.

The angular frequency should be specified in rad/s. The pulse phase can be
either specified as an angle in radians, or as one of the following symbols:
`:x`, `:y`, `:_x`, or `:_y`, which correspond respectively to 0, π/2, π, and
3π/2.
"""
function h_pulse(sys, nuc, ω1::Frequency, φ)
    n = length(sys.nuclei)
    # Assume that pulses only apply to one nucleus
    indices = findall(==(nuc), sys.nuclei)
    # Convert pulse phase to radians if needed
    if φ === :x
        φ = 0
    elseif φ === :y
        φ = π / 2
    elseif φ === :_x
        φ = π
    elseif φ === :_y
        φ = 3π / 2
    end
    single_spin_op = cos(φ) * σ_x + sin(φ) * σ_y
    return sum([ω1 * op1(i, n, single_spin_op) for i in indices])
end
